"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/api/MessageRuntime.ts
var MessageRuntime_exports = {};
__export(MessageRuntime_exports, {
  EMPTY_CONTENT_SYMBOL: () => EMPTY_CONTENT_SYMBOL,
  MessageRuntimeImpl: () => MessageRuntimeImpl,
  toContentPartStatus: () => toContentPartStatus
});
module.exports = __toCommonJS(MessageRuntime_exports);
var import_getThreadMessageText = require("../utils/getThreadMessageText.js");
var import_AttachmentRuntime = require("./AttachmentRuntime.js");
var import_ComposerRuntime = require("./ComposerRuntime.js");
var import_ContentPartRuntime = require("./ContentPartRuntime.js");
var import_NestedSubscriptionSubject = require("./subscribable/NestedSubscriptionSubject.js");
var import_SKIP_UPDATE = require("./subscribable/SKIP_UPDATE.js");
var import_ShallowMemoizeSubject = require("./subscribable/ShallowMemoizeSubject.js");
var COMPLETE_STATUS = Object.freeze({
  type: "complete"
});
var toContentPartStatus = (message, partIndex, part) => {
  if (message.role !== "assistant") return COMPLETE_STATUS;
  if (part.type === "tool-call") {
    if (!part.result) {
      return message.status;
    } else {
      return COMPLETE_STATUS;
    }
  }
  const isLastPart = partIndex === Math.max(0, message.content.length - 1);
  if (message.status.type === "requires-action") return COMPLETE_STATUS;
  return isLastPart ? message.status : COMPLETE_STATUS;
};
var EMPTY_CONTENT_SYMBOL = Symbol("empty-content");
var EMPTY_CONTENT = Object.freeze({
  type: "text",
  text: "",
  [EMPTY_CONTENT_SYMBOL]: true
});
var getContentPartState = (message, partIndex) => {
  let part = message.content[partIndex];
  if (!part) {
    if (message.content.length === 0 && partIndex === 0) {
      part = EMPTY_CONTENT;
    } else {
      return import_SKIP_UPDATE.SKIP_UPDATE;
    }
  } else if (message.content.length === 1 && part.type === "text" && part.text.length === 0) {
    part = EMPTY_CONTENT;
  }
  const status = toContentPartStatus(message, partIndex, part);
  return Object.freeze({ ...part, status });
};
var MessageRuntimeImpl = class {
  constructor(_core, _threadBinding) {
    this._core = _core;
    this._threadBinding = _threadBinding;
    this.composer = new import_ComposerRuntime.EditComposerRuntimeImpl(
      new import_NestedSubscriptionSubject.NestedSubscriptionSubject({
        path: {
          ...this.path,
          ref: this.path.ref + `${this.path.ref}.composer`,
          composerSource: "edit"
        },
        getState: () => this._threadBinding.getState().getEditComposer(this._core.getState().id),
        subscribe: (callback) => this._threadBinding.subscribe(callback)
      }),
      () => this._threadBinding.getState().beginEdit(this._core.getState().id)
    );
  }
  get path() {
    return this._core.path;
  }
  composer;
  getState() {
    return this._core.getState();
  }
  reload({ runConfig = {} } = {}) {
    const state = this._core.getState();
    if (state.role !== "assistant")
      throw new Error("Can only reload assistant messages");
    this._threadBinding.getState().startRun({
      parentId: state.parentId,
      sourceId: state.id,
      runConfig
    });
  }
  speak() {
    const state = this._core.getState();
    return this._threadBinding.getState().speak(state.id);
  }
  stopSpeaking() {
    const state = this._core.getState();
    const thread = this._threadBinding.getState();
    if (thread.speech?.messageId === state.id) {
      this._threadBinding.getState().stopSpeaking();
    } else {
      throw new Error("Message is not being spoken");
    }
  }
  submitFeedback({ type }) {
    const state = this._core.getState();
    this._threadBinding.getState().submitFeedback({
      messageId: state.id,
      type
    });
  }
  switchToBranch({
    position,
    branchId
  }) {
    const state = this._core.getState();
    if (branchId && position) {
      throw new Error("May not specify both branchId and position");
    } else if (!branchId && !position) {
      throw new Error("Must specify either branchId or position");
    }
    const thread = this._threadBinding.getState();
    const branches = thread.getBranches(state.id);
    let targetBranch = branchId;
    if (position === "previous") {
      targetBranch = branches[state.branchNumber - 2];
    } else if (position === "next") {
      targetBranch = branches[state.branchNumber];
    }
    if (!targetBranch) throw new Error("Branch not found");
    this._threadBinding.getState().switchToBranch(targetBranch);
  }
  unstable_getCopyText() {
    return (0, import_getThreadMessageText.getThreadMessageText)(this.getState());
  }
  subscribe(callback) {
    return this._core.subscribe(callback);
  }
  getContentPartByIndex(idx) {
    if (idx < 0) throw new Error("Content part index must be >= 0");
    return new import_ContentPartRuntime.ContentPartRuntimeImpl(
      new import_ShallowMemoizeSubject.ShallowMemoizeSubject({
        path: {
          ...this.path,
          ref: this.path.ref + `${this.path.ref}.content[${idx}]`,
          contentPartSelector: { type: "index", index: idx }
        },
        getState: () => {
          return getContentPartState(this.getState(), idx);
        },
        subscribe: (callback) => this._core.subscribe(callback)
      }),
      this._core,
      this._threadBinding
    );
  }
  getContentPartByToolCallId(toolCallId) {
    return new import_ContentPartRuntime.ContentPartRuntimeImpl(
      new import_ShallowMemoizeSubject.ShallowMemoizeSubject({
        path: {
          ...this.path,
          ref: this.path.ref + `${this.path.ref}.content[toolCallId=${JSON.stringify(toolCallId)}]`,
          contentPartSelector: { type: "toolCallId", toolCallId }
        },
        getState: () => {
          const state = this._core.getState();
          const idx = state.content.findIndex(
            (part) => part.type === "tool-call" && part.toolCallId === toolCallId
          );
          if (idx === -1) return import_SKIP_UPDATE.SKIP_UPDATE;
          return getContentPartState(state, idx);
        },
        subscribe: (callback) => this._core.subscribe(callback)
      }),
      this._core,
      this._threadBinding
    );
  }
  getAttachmentByIndex(idx) {
    return new import_AttachmentRuntime.MessageAttachmentRuntimeImpl(
      new import_ShallowMemoizeSubject.ShallowMemoizeSubject({
        path: {
          ...this.path,
          ref: this.path.ref + `${this.path.ref}.attachments[${idx}]`,
          attachmentSource: "message",
          attachmentSelector: { type: "index", index: idx }
        },
        getState: () => {
          const attachments = this.getState().attachments;
          const attachment = attachments?.[idx];
          if (!attachment) return import_SKIP_UPDATE.SKIP_UPDATE;
          return {
            ...attachment,
            source: "message"
          };
        },
        subscribe: (callback) => this._core.subscribe(callback)
      })
    );
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  EMPTY_CONTENT_SYMBOL,
  MessageRuntimeImpl,
  toContentPartStatus
});
//# sourceMappingURL=MessageRuntime.js.map