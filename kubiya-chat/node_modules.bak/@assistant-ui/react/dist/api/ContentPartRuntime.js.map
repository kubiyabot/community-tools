{"version":3,"sources":["../../src/api/ContentPartRuntime.ts"],"sourcesContent":["import {\n  ThreadAssistantContentPart,\n  ThreadUserContentPart,\n  ContentPartStatus,\n  ToolCallContentPartStatus,\n} from \"../types/AssistantTypes\";\nimport { ThreadRuntimeCoreBinding } from \"./ThreadRuntime\";\nimport { MessageStateBinding } from \"./MessageRuntime\";\nimport { SubscribableWithState } from \"./subscribable/Subscribable\";\nimport { Unsubscribe } from \"../types\";\nimport { ContentPartRuntimePath } from \"./RuntimePathTypes\";\n\nexport type ContentPartState = (\n  | ThreadUserContentPart\n  | ThreadAssistantContentPart\n) & {\n  readonly status: ContentPartStatus | ToolCallContentPartStatus;\n};\n\ntype ContentPartSnapshotBinding = SubscribableWithState<\n  ContentPartState,\n  ContentPartRuntimePath\n>;\n\nexport type ContentPartRuntime = {\n  /**\n   * Add tool result to a tool call content part that has no tool result yet.\n   * This is useful when you are collecting a tool result via user input (\"human tool calls\").\n   */\n  addToolResult(result: any): void;\n\n  readonly path: ContentPartRuntimePath;\n  getState(): ContentPartState;\n  subscribe(callback: () => void): Unsubscribe;\n};\n\nexport class ContentPartRuntimeImpl implements ContentPartRuntime {\n  public get path() {\n    return this.contentBinding.path;\n  }\n\n  constructor(\n    private contentBinding: ContentPartSnapshotBinding,\n    private messageApi?: MessageStateBinding,\n    private threadApi?: ThreadRuntimeCoreBinding,\n  ) {}\n\n  public getState() {\n    return this.contentBinding.getState();\n  }\n\n  public addToolResult(result: any) {\n    const state = this.contentBinding.getState();\n    if (!state) throw new Error(\"Content part is not available\");\n\n    if (state.type !== \"tool-call\")\n      throw new Error(\"Tried to add tool result to non-tool content part\");\n\n    if (!this.messageApi)\n      throw new Error(\n        \"Message API is not available. This is likely a bug in assistant-ui.\",\n      );\n    if (!this.threadApi) throw new Error(\"Thread API is not available\");\n\n    const message = this.messageApi.getState();\n    if (!message) throw new Error(\"Message is not available\");\n\n    const toolName = state.toolName;\n    const toolCallId = state.toolCallId;\n\n    this.threadApi.getState().addToolResult({\n      messageId: message.id,\n      toolName,\n      toolCallId,\n      result,\n    });\n  }\n\n  public subscribe(callback: () => void) {\n    return this.contentBinding.subscribe(callback);\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAoCO,IAAM,yBAAN,MAA2D;AAAA,EAKhE,YACU,gBACA,YACA,WACR;AAHQ;AACA;AACA;AAAA,EACP;AAAA,EARH,IAAW,OAAO;AAChB,WAAO,KAAK,eAAe;AAAA,EAC7B;AAAA,EAQO,WAAW;AAChB,WAAO,KAAK,eAAe,SAAS;AAAA,EACtC;AAAA,EAEO,cAAc,QAAa;AAChC,UAAM,QAAQ,KAAK,eAAe,SAAS;AAC3C,QAAI,CAAC,MAAO,OAAM,IAAI,MAAM,+BAA+B;AAE3D,QAAI,MAAM,SAAS;AACjB,YAAM,IAAI,MAAM,mDAAmD;AAErE,QAAI,CAAC,KAAK;AACR,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AACF,QAAI,CAAC,KAAK,UAAW,OAAM,IAAI,MAAM,6BAA6B;AAElE,UAAM,UAAU,KAAK,WAAW,SAAS;AACzC,QAAI,CAAC,QAAS,OAAM,IAAI,MAAM,0BAA0B;AAExD,UAAM,WAAW,MAAM;AACvB,UAAM,aAAa,MAAM;AAEzB,SAAK,UAAU,SAAS,EAAE,cAAc;AAAA,MACtC,WAAW,QAAQ;AAAA,MACnB;AAAA,MACA;AAAA,MACA;AAAA,IACF,CAAC;AAAA,EACH;AAAA,EAEO,UAAU,UAAsB;AACrC,WAAO,KAAK,eAAe,UAAU,QAAQ;AAAA,EAC/C;AACF;","names":[]}