{"version":3,"sources":["../../../../src/runtimes/edge/streams/toolResultStream.ts"],"sourcesContent":["import { Tool } from \"../../../types/ModelConfigTypes\";\nimport { JSONValue, LanguageModelV1StreamPart } from \"@ai-sdk/provider\";\nimport { z } from \"zod\";\nimport sjson from \"secure-json-parse\";\n\nexport type ToolResultStreamPart =\n  | LanguageModelV1StreamPart\n  | {\n      type: \"data\";\n      data: JSONValue[];\n    }\n  | {\n      type: \"tool-result\";\n      toolCallType: \"function\";\n      toolCallId: string;\n      toolName: string;\n      result: unknown;\n      isError?: boolean;\n    }\n  | {\n      type: \"step-finish\";\n      finishReason:\n        | \"stop\"\n        | \"length\"\n        | \"content-filter\"\n        | \"tool-calls\"\n        | \"error\"\n        | \"other\"\n        | \"unknown\";\n      usage: {\n        promptTokens: number;\n        completionTokens: number;\n      };\n      isContinued: boolean;\n    };\n\nexport function toolResultStream(\n  tools: Record<string, Tool> | undefined,\n  abortSignal: AbortSignal,\n) {\n  const toolCallExecutions = new Map<string, Promise<any>>();\n\n  return new TransformStream<ToolResultStreamPart, ToolResultStreamPart>({\n    transform(chunk, controller) {\n      // forward everything\n      controller.enqueue(chunk);\n\n      // handle tool calls\n      const chunkType = chunk.type;\n      switch (chunkType) {\n        case \"tool-call\": {\n          const { toolCallId, toolCallType, toolName, args: argsText } = chunk;\n          const tool = tools?.[toolName];\n          if (!tool || !tool.execute) return;\n\n          let args;\n          try {\n            args = sjson.parse(argsText);\n          } catch (e) {\n            controller.enqueue({\n              type: \"tool-result\",\n              toolCallType,\n              toolCallId,\n              toolName,\n              result:\n                \"Function parameter parsing failed. \" +\n                JSON.stringify((e as Error).message),\n              isError: true,\n            });\n            return;\n          }\n\n          if (tool.parameters instanceof z.ZodType) {\n            const result = tool.parameters.safeParse(args);\n            if (!result.success) {\n              controller.enqueue({\n                type: \"tool-result\",\n                toolCallType,\n                toolCallId,\n                toolName,\n                result:\n                  \"Function parameter validation failed. \" +\n                  JSON.stringify(result.error.issues),\n                isError: true,\n              });\n              return;\n            }\n          }\n\n          toolCallExecutions.set(\n            toolCallId,\n            (async () => {\n              if (!tool.execute) return;\n\n              try {\n                const result = await tool.execute(args, { abortSignal });\n\n                controller.enqueue({\n                  type: \"tool-result\",\n                  toolCallType,\n                  toolCallId,\n                  toolName,\n                  result,\n                });\n              } catch (error) {\n                controller.enqueue({\n                  type: \"tool-result\",\n                  toolCallType,\n                  toolCallId,\n                  toolName,\n                  result: \"Error: \" + error,\n                  isError: true,\n                });\n              } finally {\n                toolCallExecutions.delete(toolCallId);\n              }\n            })(),\n          );\n          break;\n        }\n\n        // ignore other parts\n        case \"text-delta\":\n        case \"tool-call-delta\":\n        case \"tool-result\":\n        case \"step-finish\":\n        case \"finish\":\n        case \"error\":\n        case \"response-metadata\":\n        case \"data\":\n          break;\n\n        default: {\n          const unhandledType: never = chunkType;\n          throw new Error(`Unhandled chunk type: ${unhandledType}`);\n        }\n      }\n    },\n\n    async flush() {\n      await Promise.all(toolCallExecutions.values());\n    },\n  });\n}\n"],"mappings":";AAEA,SAAS,SAAS;AAClB,OAAO,WAAW;AAiCX,SAAS,iBACd,OACA,aACA;AACA,QAAM,qBAAqB,oBAAI,IAA0B;AAEzD,SAAO,IAAI,gBAA4D;AAAA,IACrE,UAAU,OAAO,YAAY;AAE3B,iBAAW,QAAQ,KAAK;AAGxB,YAAM,YAAY,MAAM;AACxB,cAAQ,WAAW;AAAA,QACjB,KAAK,aAAa;AAChB,gBAAM,EAAE,YAAY,cAAc,UAAU,MAAM,SAAS,IAAI;AAC/D,gBAAM,OAAO,QAAQ,QAAQ;AAC7B,cAAI,CAAC,QAAQ,CAAC,KAAK,QAAS;AAE5B,cAAI;AACJ,cAAI;AACF,mBAAO,MAAM,MAAM,QAAQ;AAAA,UAC7B,SAAS,GAAG;AACV,uBAAW,QAAQ;AAAA,cACjB,MAAM;AAAA,cACN;AAAA,cACA;AAAA,cACA;AAAA,cACA,QACE,wCACA,KAAK,UAAW,EAAY,OAAO;AAAA,cACrC,SAAS;AAAA,YACX,CAAC;AACD;AAAA,UACF;AAEA,cAAI,KAAK,sBAAsB,EAAE,SAAS;AACxC,kBAAM,SAAS,KAAK,WAAW,UAAU,IAAI;AAC7C,gBAAI,CAAC,OAAO,SAAS;AACnB,yBAAW,QAAQ;AAAA,gBACjB,MAAM;AAAA,gBACN;AAAA,gBACA;AAAA,gBACA;AAAA,gBACA,QACE,2CACA,KAAK,UAAU,OAAO,MAAM,MAAM;AAAA,gBACpC,SAAS;AAAA,cACX,CAAC;AACD;AAAA,YACF;AAAA,UACF;AAEA,6BAAmB;AAAA,YACjB;AAAA,aACC,YAAY;AACX,kBAAI,CAAC,KAAK,QAAS;AAEnB,kBAAI;AACF,sBAAM,SAAS,MAAM,KAAK,QAAQ,MAAM,EAAE,YAAY,CAAC;AAEvD,2BAAW,QAAQ;AAAA,kBACjB,MAAM;AAAA,kBACN;AAAA,kBACA;AAAA,kBACA;AAAA,kBACA;AAAA,gBACF,CAAC;AAAA,cACH,SAAS,OAAO;AACd,2BAAW,QAAQ;AAAA,kBACjB,MAAM;AAAA,kBACN;AAAA,kBACA;AAAA,kBACA;AAAA,kBACA,QAAQ,YAAY;AAAA,kBACpB,SAAS;AAAA,gBACX,CAAC;AAAA,cACH,UAAE;AACA,mCAAmB,OAAO,UAAU;AAAA,cACtC;AAAA,YACF,GAAG;AAAA,UACL;AACA;AAAA,QACF;AAAA;AAAA,QAGA,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK;AAAA,QACL,KAAK;AACH;AAAA,QAEF,SAAS;AACP,gBAAM,gBAAuB;AAC7B,gBAAM,IAAI,MAAM,yBAAyB,aAAa,EAAE;AAAA,QAC1D;AAAA,MACF;AAAA,IACF;AAAA,IAEA,MAAM,QAAQ;AACZ,YAAM,QAAQ,IAAI,mBAAmB,OAAO,CAAC;AAAA,IAC/C;AAAA,EACF,CAAC;AACH;","names":[]}