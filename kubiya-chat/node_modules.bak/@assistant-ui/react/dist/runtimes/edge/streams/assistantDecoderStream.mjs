// src/runtimes/edge/streams/assistantDecoderStream.ts
import {
  AssistantStreamChunkType
} from "./AssistantStreamChunkType.mjs";
function assistantDecoderStream() {
  const toolCallNames = /* @__PURE__ */ new Map();
  let currentToolCall;
  const endCurrentToolCall = (controller) => {
    if (!currentToolCall) return;
    controller.enqueue({
      type: "tool-call",
      toolCallType: "function",
      toolCallId: currentToolCall.id,
      toolName: currentToolCall.name,
      args: currentToolCall.argsText
    });
    currentToolCall = void 0;
  };
  return new TransformStream({
    transform({ type, value }, controller) {
      if (type !== AssistantStreamChunkType.ToolCallDelta && type !== AssistantStreamChunkType.Error) {
        endCurrentToolCall(controller);
      }
      switch (type) {
        case AssistantStreamChunkType.TextDelta: {
          controller.enqueue({
            type: "text-delta",
            textDelta: value
          });
          break;
        }
        case AssistantStreamChunkType.ToolCallBegin: {
          const { toolCallId: id, toolName: name } = value;
          toolCallNames.set(id, name);
          currentToolCall = { id, name, argsText: "" };
          controller.enqueue({
            type: "tool-call-delta",
            toolCallType: "function",
            toolCallId: id,
            toolName: name,
            argsTextDelta: ""
          });
          break;
        }
        case AssistantStreamChunkType.ToolCallDelta: {
          const { toolCallId, argsTextDelta } = value;
          const toolName = toolCallNames.get(toolCallId);
          if (currentToolCall?.id === toolCallId) {
            currentToolCall.argsText += argsTextDelta;
          }
          controller.enqueue({
            type: "tool-call-delta",
            toolCallType: "function",
            toolCallId,
            toolName,
            argsTextDelta
          });
          break;
        }
        case AssistantStreamChunkType.ToolCallResult: {
          controller.enqueue({
            type: "tool-result",
            toolCallType: "function",
            toolCallId: value.toolCallId,
            toolName: toolCallNames.get(value.toolCallId),
            result: value.result
          });
          break;
        }
        case AssistantStreamChunkType.Finish: {
          controller.enqueue({
            type: "finish",
            ...value
          });
          break;
        }
        case AssistantStreamChunkType.Error: {
          controller.enqueue({
            type: "error",
            error: value
          });
          break;
        }
        case AssistantStreamChunkType.ToolCall: {
          const { toolCallId, toolName, args } = value;
          toolCallNames.set(toolCallId, toolName);
          const argsText = JSON.stringify(args);
          controller.enqueue({
            type: "tool-call-delta",
            toolCallType: "function",
            toolCallId,
            toolName,
            argsTextDelta: argsText
          });
          controller.enqueue({
            type: "tool-call",
            toolCallType: "function",
            toolCallId,
            toolName,
            args: argsText
          });
          break;
        }
        case AssistantStreamChunkType.StepFinish: {
          controller.enqueue({
            type: "step-finish",
            ...value
          });
          break;
        }
        case AssistantStreamChunkType.Data:
          controller.enqueue({
            type: "data",
            data: value
          });
          break;
        // TODO
        case AssistantStreamChunkType.Annotation:
          break;
        default: {
          const unhandledType = type;
          throw new Error(`Unhandled chunk type: ${unhandledType}`);
        }
      }
    },
    flush(controller) {
      endCurrentToolCall(controller);
    }
  });
}
export {
  assistantDecoderStream
};
//# sourceMappingURL=assistantDecoderStream.mjs.map