{"version":3,"sources":["../../../../src/runtimes/edge/streams/runResultStream.ts"],"sourcesContent":["import { CoreChatModelRunResult } from \"../../local/ChatModelAdapter\";\nimport { parsePartialJson } from \"../partial-json/parse-partial-json\";\nimport { LanguageModelV1StreamPart } from \"@ai-sdk/provider\";\nimport { ToolResultStreamPart } from \"./toolResultStream\";\nimport { MessageStatus, ToolCallContentPart } from \"../../../types\";\n\nexport function runResultStream() {\n  let message: CoreChatModelRunResult = {\n    content: [],\n    status: { type: \"running\" },\n  };\n\n  return new TransformStream<ToolResultStreamPart, CoreChatModelRunResult>({\n    transform(chunk, controller) {\n      const chunkType = chunk.type;\n      switch (chunkType) {\n        case \"text-delta\": {\n          message = appendOrUpdateText(message, chunk.textDelta);\n          controller.enqueue(message);\n          break;\n        }\n\n        case \"tool-call-delta\": {\n          const { toolCallId, toolName, argsTextDelta } = chunk;\n\n          message = appendOrUpdateToolCall(\n            message,\n            toolCallId,\n            toolName,\n            argsTextDelta,\n          );\n          controller.enqueue(message);\n          break;\n        }\n\n        case \"tool-call\":\n        // ignoring tool call events because they are converted to tool-call-delta as well\n        case \"response-metadata\":\n          break;\n\n        case \"data\": {\n          message = appendData(message, chunk);\n          controller.enqueue(message);\n          break;\n        }\n\n        case \"tool-result\": {\n          message = appendOrUpdateToolResult(\n            message,\n            chunk.toolCallId,\n            chunk.toolName,\n            chunk.result,\n          );\n          controller.enqueue(message);\n          break;\n        }\n        case \"step-finish\": {\n          message = appendStepFinish(message, chunk);\n          controller.enqueue(message);\n          break;\n        }\n        case \"finish\": {\n          message = appendOrUpdateFinish(message, chunk);\n          controller.enqueue(message);\n          break;\n        }\n        case \"error\": {\n          if (\n            chunk.error instanceof Error &&\n            chunk.error.name === \"AbortError\"\n          ) {\n            message = appendOrUpdateCancel(message);\n            controller.enqueue(message);\n            break;\n          } else {\n            throw chunk.error;\n          }\n        }\n        default: {\n          const unhandledType: never = chunkType;\n          throw new Error(`Unhandled chunk type: ${unhandledType}`);\n        }\n      }\n    },\n    flush(controller) {\n      if (message.status?.type === \"running\") {\n        const requiresAction = message.content?.at(-1)?.type === \"tool-call\";\n        message = appendOrUpdateFinish(message, {\n          type: \"finish\",\n          finishReason: requiresAction ? \"tool-calls\" : \"unknown\",\n          usage: {\n            promptTokens: 0,\n            completionTokens: 0,\n          },\n        });\n        controller.enqueue(message);\n      }\n    },\n  });\n}\n\nconst appendOrUpdateText = (\n  message: CoreChatModelRunResult,\n  textDelta: string,\n) => {\n  let contentParts = message.content ?? [];\n  let contentPart = message.content?.at(-1);\n  if (contentPart?.type !== \"text\") {\n    contentPart = { type: \"text\", text: textDelta };\n  } else {\n    contentParts = contentParts.slice(0, -1);\n    contentPart = { type: \"text\", text: contentPart.text + textDelta };\n  }\n  return {\n    ...message,\n    content: contentParts.concat([contentPart]),\n  };\n};\n\nconst appendOrUpdateToolCall = (\n  message: CoreChatModelRunResult,\n  toolCallId: string,\n  toolName: string,\n  argsTextDelta: string,\n): CoreChatModelRunResult => {\n  let contentParts = message.content ?? [];\n  const contentPartIdx = contentParts.findIndex(\n    (c) => c.type === \"tool-call\" && c.toolCallId === toolCallId,\n  );\n  let contentPart =\n    contentPartIdx === -1\n      ? null\n      : (contentParts[contentPartIdx] as ToolCallContentPart);\n\n  if (contentPart == null) {\n    contentPart = {\n      type: \"tool-call\",\n      toolCallId,\n      toolName,\n      argsText: argsTextDelta,\n      args: parsePartialJson(argsTextDelta),\n    };\n    contentParts = [...contentParts, contentPart];\n  } else {\n    const argsText = contentPart.argsText + argsTextDelta;\n    contentPart = {\n      ...contentPart,\n      argsText,\n      args: parsePartialJson(argsText),\n    };\n    contentParts = [\n      ...contentParts.slice(0, contentPartIdx),\n      contentPart,\n      ...contentParts.slice(contentPartIdx + 1),\n    ];\n  }\n\n  return {\n    ...message,\n    content: contentParts,\n  };\n};\n\nconst appendOrUpdateToolResult = (\n  message: CoreChatModelRunResult,\n  toolCallId: string,\n  toolName: string,\n  result: any,\n) => {\n  let found = false;\n  const newContentParts = message.content?.map((part) => {\n    if (part.type !== \"tool-call\" || part.toolCallId !== toolCallId)\n      return part;\n    found = true;\n\n    if (part.toolName !== toolName)\n      throw new Error(\n        `Tool call ${toolCallId} found with tool name ${part.toolName}, but expected ${toolName}`,\n      );\n\n    return {\n      ...part,\n      result,\n    };\n  });\n  if (!found)\n    throw new Error(\n      `Received tool result for unknown tool call \"${toolName}\" / \"${toolCallId}\". This is likely an internal bug in assistant-ui.`,\n    );\n\n  return {\n    ...message,\n    content: newContentParts!,\n  };\n};\n\nconst appendData = (\n  message: CoreChatModelRunResult,\n  chunk: ToolResultStreamPart & { type: \"data\" },\n): CoreChatModelRunResult => {\n  return {\n    ...message,\n    metadata: {\n      ...message.metadata,\n      unstable_data: [\n        ...(message.metadata?.unstable_data ?? []),\n        ...chunk.data,\n      ],\n    },\n  };\n};\n\nconst appendStepFinish = (\n  message: CoreChatModelRunResult,\n  chunk: ToolResultStreamPart & { type: \"step-finish\" },\n): CoreChatModelRunResult => {\n  const { type, ...rest } = chunk;\n  const steps = [\n    ...(message.metadata?.steps ?? []),\n    {\n      usage: rest.usage,\n    },\n  ];\n  return {\n    ...message,\n    metadata: {\n      ...message.metadata,\n      steps,\n    },\n  };\n};\n\nconst appendOrUpdateFinish = (\n  message: CoreChatModelRunResult,\n  chunk: LanguageModelV1StreamPart & { type: \"finish\" },\n): CoreChatModelRunResult => {\n  const { type, ...rest } = chunk;\n\n  const steps = [\n    ...(message.metadata?.steps ?? []),\n    {\n      logprobs: rest.logprobs,\n      usage: rest.usage,\n    },\n  ];\n  return {\n    ...message,\n    status: getStatus(chunk),\n    metadata: {\n      ...message.metadata,\n      steps,\n    },\n  };\n};\n\nconst getStatus = (\n  chunk:\n    | (LanguageModelV1StreamPart & { type: \"finish\" })\n    | (ToolResultStreamPart & { type: \"step-finish\" }),\n): MessageStatus => {\n  if (chunk.finishReason === \"tool-calls\") {\n    return {\n      type: \"requires-action\",\n      reason: \"tool-calls\",\n    };\n  } else if (\n    chunk.finishReason === \"stop\" ||\n    chunk.finishReason === \"unknown\"\n  ) {\n    return {\n      type: \"complete\",\n      reason: chunk.finishReason,\n    };\n  } else {\n    return {\n      type: \"incomplete\",\n      reason: chunk.finishReason,\n    };\n  }\n};\n\nconst appendOrUpdateCancel = (\n  message: CoreChatModelRunResult,\n): CoreChatModelRunResult => {\n  return {\n    ...message,\n    status: {\n      type: \"incomplete\",\n      reason: \"cancelled\",\n    },\n  };\n};\n"],"mappings":"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","names":[]}