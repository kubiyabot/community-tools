"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/runtimes/edge/streams/toolResultStream.ts
var toolResultStream_exports = {};
__export(toolResultStream_exports, {
  toolResultStream: () => toolResultStream
});
module.exports = __toCommonJS(toolResultStream_exports);
var import_zod = require("zod");
var import_secure_json_parse = __toESM(require("secure-json-parse"));
function toolResultStream(tools, abortSignal) {
  const toolCallExecutions = /* @__PURE__ */ new Map();
  return new TransformStream({
    transform(chunk, controller) {
      controller.enqueue(chunk);
      const chunkType = chunk.type;
      switch (chunkType) {
        case "tool-call": {
          const { toolCallId, toolCallType, toolName, args: argsText } = chunk;
          const tool = tools?.[toolName];
          if (!tool || !tool.execute) return;
          let args;
          try {
            args = import_secure_json_parse.default.parse(argsText);
          } catch (e) {
            controller.enqueue({
              type: "tool-result",
              toolCallType,
              toolCallId,
              toolName,
              result: "Function parameter parsing failed. " + JSON.stringify(e.message),
              isError: true
            });
            return;
          }
          if (tool.parameters instanceof import_zod.z.ZodType) {
            const result = tool.parameters.safeParse(args);
            if (!result.success) {
              controller.enqueue({
                type: "tool-result",
                toolCallType,
                toolCallId,
                toolName,
                result: "Function parameter validation failed. " + JSON.stringify(result.error.issues),
                isError: true
              });
              return;
            }
          }
          toolCallExecutions.set(
            toolCallId,
            (async () => {
              if (!tool.execute) return;
              try {
                const result = await tool.execute(args, { abortSignal });
                controller.enqueue({
                  type: "tool-result",
                  toolCallType,
                  toolCallId,
                  toolName,
                  result
                });
              } catch (error) {
                controller.enqueue({
                  type: "tool-result",
                  toolCallType,
                  toolCallId,
                  toolName,
                  result: "Error: " + error,
                  isError: true
                });
              } finally {
                toolCallExecutions.delete(toolCallId);
              }
            })()
          );
          break;
        }
        // ignore other parts
        case "text-delta":
        case "tool-call-delta":
        case "tool-result":
        case "step-finish":
        case "finish":
        case "error":
        case "response-metadata":
        case "data":
          break;
        default: {
          const unhandledType = chunkType;
          throw new Error(`Unhandled chunk type: ${unhandledType}`);
        }
      }
    },
    async flush() {
      await Promise.all(toolCallExecutions.values());
    }
  });
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  toolResultStream
});
//# sourceMappingURL=toolResultStream.js.map