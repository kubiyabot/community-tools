"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/runtimes/edge/converters/toLanguageModelMessages.ts
var toLanguageModelMessages_exports = {};
__export(toLanguageModelMessages_exports, {
  toLanguageModelMessages: () => toLanguageModelMessages
});
module.exports = __toCommonJS(toLanguageModelMessages_exports);
var assistantMessageSplitter = () => {
  const stash = [];
  let assistantMessage = {
    role: "assistant",
    content: []
  };
  let toolMessage = {
    role: "tool",
    content: []
  };
  return {
    addTextContentPart: (part) => {
      if (toolMessage.content.length > 0) {
        stash.push(assistantMessage);
        stash.push(toolMessage);
        assistantMessage = {
          role: "assistant",
          content: []
        };
        toolMessage = {
          role: "tool",
          content: []
        };
      }
      assistantMessage.content.push(part);
    },
    addToolCallPart: (part) => {
      assistantMessage.content.push({
        type: "tool-call",
        toolCallId: part.toolCallId,
        toolName: part.toolName,
        args: part.args
      });
      toolMessage.content.push({
        type: "tool-result",
        toolCallId: part.toolCallId,
        toolName: part.toolName,
        result: part.result ?? "<no result>",
        isError: part.isError ?? false
      });
    },
    getMessages: () => {
      if (toolMessage.content.length > 0) {
        return [...stash, assistantMessage, toolMessage];
      }
      return [...stash, assistantMessage];
    }
  };
};
function toLanguageModelMessages(message) {
  return message.flatMap((message2) => {
    const role = message2.role;
    switch (role) {
      case "system": {
        return [{ role: "system", content: message2.content[0].text }];
      }
      case "user": {
        const attachments = "attachments" in message2 ? message2.attachments : [];
        const content = [
          ...message2.content,
          ...attachments.map((a) => a.content).flat()
        ];
        const msg = {
          role: "user",
          content: content.map(
            (part) => {
              const type = part.type;
              switch (type) {
                case "text": {
                  return part;
                }
                case "image": {
                  return {
                    type: "image",
                    image: new URL(part.image)
                  };
                }
                case "file": {
                  return {
                    type: "file",
                    data: new URL(part.data),
                    mimeType: part.mimeType
                  };
                }
                default: {
                  const unhandledType = type;
                  throw new Error(
                    `Unspported content part type: ${unhandledType}`
                  );
                }
              }
            }
          )
        };
        return [msg];
      }
      case "assistant": {
        const splitter = assistantMessageSplitter();
        for (const part of message2.content) {
          const type = part.type;
          switch (type) {
            case "text": {
              splitter.addTextContentPart(part);
              break;
            }
            case "tool-call": {
              splitter.addToolCallPart(part);
              break;
            }
            default: {
              const unhandledType = type;
              throw new Error(`Unhandled content part type: ${unhandledType}`);
            }
          }
        }
        return splitter.getMessages();
      }
      default: {
        const unhandledRole = role;
        throw new Error(`Unknown message role: ${unhandledRole}`);
      }
    }
  });
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  toLanguageModelMessages
});
//# sourceMappingURL=toLanguageModelMessages.js.map