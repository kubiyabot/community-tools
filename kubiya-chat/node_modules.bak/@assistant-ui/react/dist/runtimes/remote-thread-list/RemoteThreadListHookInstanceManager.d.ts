import { FC } from "react";
import { BaseSubscribable } from "./BaseSubscribable";
import { RemoteThreadListHook } from "./types";
export declare class RemoteThreadListHookInstanceManager extends BaseSubscribable {
    private useRuntimeHook;
    private instances;
    private useAliveThreadsKeysChanged;
    constructor(runtimeHook: RemoteThreadListHook);
    startThreadRuntime(threadId: string): Promise<Readonly<{
        getMessageById: (messageId: string) => {
            parentId: string | null;
            message: import("../..").ThreadMessage;
        } | undefined;
        getBranches: (messageId: string) => readonly string[];
        switchToBranch: (branchId: string) => void;
        append: (message: import("../..").AppendMessage) => void;
        startRun: (config: import("../core/ThreadRuntimeCore").StartRunConfig) => void;
        cancelRun: () => void;
        addToolResult: (options: import("..").AddToolResultOptions) => void;
        speak: (messageId: string) => void;
        stopSpeaking: () => void;
        getSubmittedFeedback: (messageId: string) => import("../core/ThreadRuntimeCore").SubmittedFeedback | undefined;
        submitFeedback: (feedback: import("..").SubmitFeedbackOptions) => void;
        getModelConfig: () => import("../..").ModelConfig;
        composer: import("../core/ComposerRuntimeCore").ThreadComposerRuntimeCore;
        getEditComposer: (messageId: string) => import("../core/ComposerRuntimeCore").ComposerRuntimeCore | undefined;
        beginEdit: (messageId: string) => void;
        speech: import("../core/ThreadRuntimeCore").SpeechState | undefined;
        capabilities: Readonly<import("../core/ThreadRuntimeCore").RuntimeCapabilities>;
        isDisabled: boolean;
        messages: readonly import("../..").ThreadMessage[];
        suggestions: readonly import("..").ThreadSuggestion[];
        extras: unknown;
        subscribe: (callback: () => void) => import("../..").Unsubscribe;
        import(repository: import("../utils/MessageRepository").ExportedMessageRepository): void;
        export(): import("../utils/MessageRepository").ExportedMessageRepository;
        unstable_on(event: import("../core/ThreadRuntimeCore").ThreadRuntimeEventType, callback: () => void): import("../..").Unsubscribe;
    }>>;
    getThreadRuntimeCore(threadId: string): Readonly<{
        getMessageById: (messageId: string) => {
            parentId: string | null;
            message: import("../..").ThreadMessage;
        } | undefined;
        getBranches: (messageId: string) => readonly string[];
        switchToBranch: (branchId: string) => void;
        append: (message: import("../..").AppendMessage) => void;
        startRun: (config: import("../core/ThreadRuntimeCore").StartRunConfig) => void;
        cancelRun: () => void;
        addToolResult: (options: import("..").AddToolResultOptions) => void;
        speak: (messageId: string) => void;
        stopSpeaking: () => void;
        getSubmittedFeedback: (messageId: string) => import("../core/ThreadRuntimeCore").SubmittedFeedback | undefined;
        submitFeedback: (feedback: import("..").SubmitFeedbackOptions) => void;
        getModelConfig: () => import("../..").ModelConfig;
        composer: import("../core/ComposerRuntimeCore").ThreadComposerRuntimeCore;
        getEditComposer: (messageId: string) => import("../core/ComposerRuntimeCore").ComposerRuntimeCore | undefined;
        beginEdit: (messageId: string) => void;
        speech: import("../core/ThreadRuntimeCore").SpeechState | undefined;
        capabilities: Readonly<import("../core/ThreadRuntimeCore").RuntimeCapabilities>;
        isDisabled: boolean;
        messages: readonly import("../..").ThreadMessage[];
        suggestions: readonly import("..").ThreadSuggestion[];
        extras: unknown;
        subscribe: (callback: () => void) => import("../..").Unsubscribe;
        import(repository: import("../utils/MessageRepository").ExportedMessageRepository): void;
        export(): import("../utils/MessageRepository").ExportedMessageRepository;
        unstable_on(event: import("../core/ThreadRuntimeCore").ThreadRuntimeEventType, callback: () => void): import("../..").Unsubscribe;
    }> | undefined;
    stopThreadRuntime(threadId: string): void;
    setRuntimeHook(newRuntimeHook: RemoteThreadListHook): void;
    private _InnerActiveThreadProvider;
    private _OuterActiveThreadProvider;
    __internal_RenderThreadRuntimes: FC;
}
//# sourceMappingURL=RemoteThreadListHookInstanceManager.d.ts.map