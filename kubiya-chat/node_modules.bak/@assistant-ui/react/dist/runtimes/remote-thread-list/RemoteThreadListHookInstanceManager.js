"use strict";
"use client";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/runtimes/remote-thread-list/RemoteThreadListHookInstanceManager.tsx
var RemoteThreadListHookInstanceManager_exports = {};
__export(RemoteThreadListHookInstanceManager_exports, {
  RemoteThreadListHookInstanceManager: () => RemoteThreadListHookInstanceManager
});
module.exports = __toCommonJS(RemoteThreadListHookInstanceManager_exports);
var import_react = require("react");
var import_zustand = require("zustand");
var import_context = require("../../context/index.js");
var import_ThreadListItemRuntimeProvider = require("../../context/providers/ThreadListItemRuntimeProvider.js");
var import_ThreadListItemContext = require("../../context/react/ThreadListItemContext.js");
var import_BaseSubscribable = require("./BaseSubscribable.js");
var import_jsx_runtime = require("react/jsx-runtime");
var RemoteThreadListHookInstanceManager = class extends import_BaseSubscribable.BaseSubscribable {
  useRuntimeHook;
  instances = /* @__PURE__ */ new Map();
  useAliveThreadsKeysChanged = (0, import_zustand.create)(() => ({}));
  constructor(runtimeHook) {
    super();
    this.useRuntimeHook = (0, import_zustand.create)(() => ({ useRuntime: runtimeHook }));
  }
  startThreadRuntime(threadId) {
    if (!this.instances.has(threadId)) {
      this.instances.set(threadId, {});
      this.useAliveThreadsKeysChanged.setState({}, true);
    }
    return new Promise((resolve, reject) => {
      const callback = () => {
        const instance = this.instances.get(threadId);
        if (!instance) {
          dispose();
          reject(new Error("Thread was deleted before runtime was started"));
        } else if (!instance.runtime) {
          return;
        } else {
          dispose();
          resolve(instance.runtime);
        }
      };
      const dispose = this.subscribe(callback);
      callback();
    });
  }
  getThreadRuntimeCore(threadId) {
    const instance = this.instances.get(threadId);
    if (!instance)
      throw new Error(
        "getThreadRuntimeCore not found. This is a bug in assistant-ui."
      );
    return instance.runtime;
  }
  stopThreadRuntime(threadId) {
    this.instances.delete(threadId);
    this.useAliveThreadsKeysChanged.setState({}, true);
  }
  setRuntimeHook(newRuntimeHook) {
    const prevRuntimeHook = this.useRuntimeHook.getState().useRuntime;
    if (prevRuntimeHook !== newRuntimeHook) {
      this.useRuntimeHook.setState({ useRuntime: newRuntimeHook }, true);
    }
  }
  _InnerActiveThreadProvider = () => {
    const { id } = (0, import_ThreadListItemContext.useThreadListItem)();
    const { useRuntime } = this.useRuntimeHook();
    const runtime = useRuntime();
    const threadBinding = runtime.thread.__internal_threadBinding;
    const updateRuntime = (0, import_react.useCallback)(() => {
      const aliveThread = this.instances.get(id);
      if (!aliveThread)
        throw new Error("Thread not found. This is a bug in assistant-ui.");
      aliveThread.runtime = threadBinding.getState();
      if (isMounted) {
        this._notifySubscribers();
      }
    }, [id, threadBinding]);
    const isMounted = (0, import_react.useRef)(false);
    if (!isMounted.current) {
      updateRuntime();
    }
    (0, import_react.useEffect)(() => {
      isMounted.current = true;
      updateRuntime();
      return threadBinding.outerSubscribe(updateRuntime);
    }, [threadBinding]);
    return null;
  };
  _OuterActiveThreadProvider = (0, import_react.memo)(
    ({ threadId }) => {
      const assistantRuntime = (0, import_context.useAssistantRuntime)();
      const threadListItemRuntime = (0, import_react.useMemo)(
        () => assistantRuntime.threadList.getItemById(threadId),
        [assistantRuntime, threadId]
      );
      return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_ThreadListItemRuntimeProvider.ThreadListItemRuntimeProvider, { runtime: threadListItemRuntime, children: /* @__PURE__ */ (0, import_jsx_runtime.jsx)(this._InnerActiveThreadProvider, {}) });
    }
  );
  __internal_RenderThreadRuntimes = () => {
    this.useAliveThreadsKeysChanged();
    return [
      ...this.instances.keys().map((threadId) => /* @__PURE__ */ (0, import_jsx_runtime.jsx)(this._OuterActiveThreadProvider, { threadId }, threadId))
    ];
  };
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  RemoteThreadListHookInstanceManager
});
//# sourceMappingURL=RemoteThreadListHookInstanceManager.js.map