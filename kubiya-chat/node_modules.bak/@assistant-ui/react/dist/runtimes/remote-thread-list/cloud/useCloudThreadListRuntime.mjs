"use client";

// src/runtimes/remote-thread-list/cloud/useCloudThreadListRuntime.tsx
import { useEffect, useMemo, useRef } from "react";
import { useRemoteThreadListRuntime } from "../useRemoteThreadListRuntime.mjs";
import { CloudContext } from "./CloudContext.mjs";
import { jsx } from "react/jsx-runtime";
var useCloudThreadListRuntime = (adapter) => {
  const adapterRef = useRef(adapter);
  useEffect(() => {
    adapterRef.current = adapter;
  }, [adapter]);
  const cloudContextValue = useMemo(() => {
    const subscribers = /* @__PURE__ */ new Set();
    return {
      initialize: async () => {
        const createTask = adapterRef.current.create?.() ?? Promise.resolve();
        const task = createTask.then(async (t) => {
          const external_id = t ? t.externalId : void 0;
          const { thread_id } = await adapterRef.current.cloud.threads.create({
            title: "New Thread",
            last_message_at: /* @__PURE__ */ new Date(),
            external_id
          });
          return { externalId: external_id, remoteId: thread_id };
        });
        for (const subscriber of subscribers) {
          subscriber(task);
        }
        return task;
      },
      subscribe: (callback) => {
        subscribers.add(callback);
        return () => {
          subscribers.delete(callback);
        };
      }
    };
  }, []);
  const runtime = useRemoteThreadListRuntime({
    runtimeHook: adapter.runtimeHook,
    list: async () => {
      const { threads } = await adapter.cloud.threads.list();
      return {
        threads: threads.map((t) => ({
          status: t.is_archived ? "archived" : "regular",
          remoteId: t.id,
          title: t.title,
          externalId: t.external_id ?? void 0
        }))
      };
    },
    rename: async (threadId, newTitle) => {
      return adapter.cloud.threads.update(threadId, { title: newTitle });
    },
    archive: async (threadId) => {
      return adapter.cloud.threads.update(threadId, { is_archived: true });
    },
    unarchive: async (threadId) => {
      return adapter.cloud.threads.update(threadId, { is_archived: false });
    },
    delete: async (threadId) => {
      await adapter.delete?.(threadId);
      return adapter.cloud.threads.delete(threadId);
    },
    onInitialize: (callback) => {
      return cloudContextValue.subscribe(callback);
    },
    unstable_Provider: ({ children }) => {
      return /* @__PURE__ */ jsx(CloudContext.Provider, { value: cloudContextValue, children });
    }
  });
  return runtime;
};
export {
  useCloudThreadListRuntime
};
//# sourceMappingURL=useCloudThreadListRuntime.mjs.map