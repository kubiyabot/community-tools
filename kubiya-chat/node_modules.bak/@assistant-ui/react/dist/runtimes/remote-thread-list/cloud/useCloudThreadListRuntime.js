"use strict";
"use client";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/runtimes/remote-thread-list/cloud/useCloudThreadListRuntime.tsx
var useCloudThreadListRuntime_exports = {};
__export(useCloudThreadListRuntime_exports, {
  useCloudThreadListRuntime: () => useCloudThreadListRuntime
});
module.exports = __toCommonJS(useCloudThreadListRuntime_exports);
var import_react = require("react");
var import_useRemoteThreadListRuntime = require("../useRemoteThreadListRuntime.js");
var import_CloudContext = require("./CloudContext.js");
var import_jsx_runtime = require("react/jsx-runtime");
var useCloudThreadListRuntime = (adapter) => {
  const adapterRef = (0, import_react.useRef)(adapter);
  (0, import_react.useEffect)(() => {
    adapterRef.current = adapter;
  }, [adapter]);
  const cloudContextValue = (0, import_react.useMemo)(() => {
    const subscribers = /* @__PURE__ */ new Set();
    return {
      initialize: async () => {
        const createTask = adapterRef.current.create?.() ?? Promise.resolve();
        const task = createTask.then(async (t) => {
          const external_id = t ? t.externalId : void 0;
          const { thread_id } = await adapterRef.current.cloud.threads.create({
            title: "New Thread",
            last_message_at: /* @__PURE__ */ new Date(),
            external_id
          });
          return { externalId: external_id, remoteId: thread_id };
        });
        for (const subscriber of subscribers) {
          subscriber(task);
        }
        return task;
      },
      subscribe: (callback) => {
        subscribers.add(callback);
        return () => {
          subscribers.delete(callback);
        };
      }
    };
  }, []);
  const runtime = (0, import_useRemoteThreadListRuntime.useRemoteThreadListRuntime)({
    runtimeHook: adapter.runtimeHook,
    list: async () => {
      const { threads } = await adapter.cloud.threads.list();
      return {
        threads: threads.map((t) => ({
          status: t.is_archived ? "archived" : "regular",
          remoteId: t.id,
          title: t.title,
          externalId: t.external_id ?? void 0
        }))
      };
    },
    rename: async (threadId, newTitle) => {
      return adapter.cloud.threads.update(threadId, { title: newTitle });
    },
    archive: async (threadId) => {
      return adapter.cloud.threads.update(threadId, { is_archived: true });
    },
    unarchive: async (threadId) => {
      return adapter.cloud.threads.update(threadId, { is_archived: false });
    },
    delete: async (threadId) => {
      await adapter.delete?.(threadId);
      return adapter.cloud.threads.delete(threadId);
    },
    onInitialize: (callback) => {
      return cloudContextValue.subscribe(callback);
    },
    unstable_Provider: ({ children }) => {
      return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(import_CloudContext.CloudContext.Provider, { value: cloudContextValue, children });
    }
  });
  return runtime;
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  useCloudThreadListRuntime
});
//# sourceMappingURL=useCloudThreadListRuntime.js.map