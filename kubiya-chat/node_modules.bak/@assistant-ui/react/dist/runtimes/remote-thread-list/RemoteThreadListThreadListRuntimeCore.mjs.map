{"version":3,"sources":["../../../src/runtimes/remote-thread-list/RemoteThreadListThreadListRuntimeCore.tsx"],"sourcesContent":["\"use client\";\n\nimport { ThreadListRuntimeCore } from \"../core/ThreadListRuntimeCore\";\nimport { generateId } from \"../../internal\";\nimport { RemoteThreadListAdapter } from \"./types\";\nimport { RemoteThreadListHookInstanceManager } from \"./RemoteThreadListHookInstanceManager\";\nimport { BaseSubscribable } from \"./BaseSubscribable\";\nimport { EMPTY_THREAD_CORE } from \"./EMPTY_THREAD_CORE\";\nimport { OptimisticState } from \"./OptimisticState\";\nimport { FC, Fragment, useEffect, useId } from \"react\";\nimport { create } from \"zustand\";\nimport { CloudInitializeResponse } from \"./cloud/CloudContext\";\n\ntype RemoteThreadData =\n  | {\n      readonly threadId: string;\n      readonly remoteId?: undefined;\n      readonly externalId?: undefined;\n      readonly status: \"new\";\n      readonly title: undefined;\n    }\n  | {\n      readonly threadId: string;\n      readonly remoteId: string;\n      readonly externalId: string | undefined;\n      readonly status: \"regular\" | \"archived\";\n      readonly title?: string | undefined;\n    };\n\ntype THREAD_MAPPING_ID = string & { __brand: \"THREAD_MAPPING_ID\" };\nfunction createThreadMappingId(id: string): THREAD_MAPPING_ID {\n  return id as THREAD_MAPPING_ID;\n}\n\ntype RemoteThreadState = {\n  readonly isLoading: boolean;\n  readonly newThreadId: string | undefined;\n  readonly threadIds: readonly string[];\n  readonly archivedThreadIds: readonly string[];\n  readonly threadIdMap: Readonly<Record<string, THREAD_MAPPING_ID>>;\n  readonly threadData: Readonly<Record<THREAD_MAPPING_ID, RemoteThreadData>>;\n};\n\nconst getThreadData = (\n  state: RemoteThreadState,\n  threadIdOrRemoteId: string,\n) => {\n  const idx = state.threadIdMap[threadIdOrRemoteId];\n  if (idx === undefined) return undefined;\n  return state.threadData[idx];\n};\n\nconst updateStatusReducer = (\n  state: RemoteThreadState,\n  threadIdOrRemoteId: string,\n  newStatus: \"regular\" | \"archived\" | \"deleted\",\n) => {\n  const data = getThreadData(state, threadIdOrRemoteId);\n  if (!data) return state;\n\n  const { threadId, remoteId, status: lastStatus } = data;\n  if (lastStatus === newStatus) return state;\n\n  const newState = { ...state };\n\n  // lastStatus\n  switch (lastStatus) {\n    case \"new\":\n      newState.newThreadId = undefined;\n      break;\n    case \"regular\":\n      newState.threadIds = newState.threadIds.filter((t) => t !== threadId);\n      break;\n    case \"archived\":\n      newState.archivedThreadIds = newState.archivedThreadIds.filter(\n        (t) => t !== threadId,\n      );\n      break;\n\n    default: {\n      const _exhaustiveCheck: never = lastStatus;\n      throw new Error(`Unsupported state: ${_exhaustiveCheck}`);\n    }\n  }\n\n  // newStatus\n  switch (newStatus) {\n    case \"regular\":\n      newState.threadIds = [...newState.threadIds, threadId];\n      break;\n\n    case \"archived\":\n      newState.archivedThreadIds = [...newState.archivedThreadIds, threadId];\n      break;\n\n    case \"deleted\":\n      newState.threadData = Object.fromEntries(\n        Object.entries(newState.threadData).filter(([key]) => key !== threadId),\n      );\n      newState.threadIdMap = Object.fromEntries(\n        Object.entries(newState.threadIdMap).filter(\n          ([key]) => key !== threadId && key !== remoteId,\n        ),\n      );\n      break;\n\n    default: {\n      const _exhaustiveCheck: never = newStatus;\n      throw new Error(`Unsupported state: ${_exhaustiveCheck}`);\n    }\n  }\n\n  if (newStatus !== \"deleted\") {\n    newState.threadData = {\n      ...newState.threadData,\n      [threadId]: {\n        ...data,\n        status: newStatus,\n      },\n    };\n  }\n\n  return newState;\n};\n\nexport class RemoteThreadListThreadListRuntimeCore\n  extends BaseSubscribable\n  implements ThreadListRuntimeCore\n{\n  private _adapter!: RemoteThreadListAdapter;\n  private _disposeOldAdapter?: () => void;\n  private readonly _hookManager: RemoteThreadListHookInstanceManager;\n\n  private readonly _loadThreadsPromise: Promise<void>;\n\n  private _mainThreadId!: string;\n  private readonly _state = new OptimisticState<RemoteThreadState>({\n    isLoading: false,\n    newThreadId: undefined,\n    threadIds: [],\n    archivedThreadIds: [],\n    threadIdMap: {},\n    threadData: {},\n  });\n\n  public getLoadThreadsPromise() {\n    return this._loadThreadsPromise;\n  }\n\n  constructor(adapter: RemoteThreadListAdapter) {\n    super();\n\n    this._state.subscribe(() => this._notifySubscribers());\n    this._hookManager = new RemoteThreadListHookInstanceManager(\n      adapter.runtimeHook,\n    );\n    this.useProvider = create(() => ({\n      Provider: adapter.unstable_Provider ?? Fragment,\n    }));\n    this.__internal_setAdapter(adapter);\n\n    this._loadThreadsPromise = this._state\n      .optimisticUpdate({\n        execute: () => adapter.list(),\n        loading: (state) => {\n          return {\n            ...state,\n            isLoading: true,\n          };\n        },\n        then: (state, l) => {\n          const newThreadIds = [];\n          const newArchivedThreadIds = [];\n          const newThreadIdMap = {} as Record<string, THREAD_MAPPING_ID>;\n          const newThreadData = {} as Record<\n            THREAD_MAPPING_ID,\n            RemoteThreadData\n          >;\n\n          for (const thread of l.threads) {\n            switch (thread.status) {\n              case \"regular\":\n                newThreadIds.push(thread.remoteId);\n                break;\n              case \"archived\":\n                newArchivedThreadIds.push(thread.remoteId);\n                break;\n              default: {\n                const _exhaustiveCheck: never = thread.status;\n                throw new Error(`Unsupported state: ${_exhaustiveCheck}`);\n              }\n            }\n\n            const mappingId = createThreadMappingId(thread.remoteId);\n            newThreadIdMap[thread.remoteId] = mappingId;\n            newThreadData[mappingId] = {\n              threadId: thread.remoteId,\n              remoteId: thread.remoteId,\n              externalId: thread.externalId,\n              status: thread.status,\n              title: thread.title,\n            };\n          }\n\n          return {\n            ...state,\n            threadIds: newThreadIds,\n            archivedThreadIds: newArchivedThreadIds,\n            threadIdMap: {\n              ...state.threadIdMap,\n              ...newThreadIdMap,\n            },\n            threadData: {\n              ...state.threadData,\n              ...newThreadData,\n            },\n          };\n        },\n      })\n      .then(() => {});\n\n    this.switchToNewThread();\n  }\n\n  private useProvider;\n\n  public __internal_setAdapter(adapter: RemoteThreadListAdapter) {\n    if (this._adapter === adapter) return;\n\n    this._adapter = adapter;\n    this._disposeOldAdapter?.();\n    this._disposeOldAdapter = this._adapter.onInitialize(this._onInitialize);\n\n    const Provider = adapter.unstable_Provider ?? Fragment;\n    if (Provider !== this.useProvider.getState().Provider) {\n      this.useProvider.setState({ Provider }, true);\n    }\n\n    this._hookManager.setRuntimeHook(adapter.runtimeHook);\n  }\n\n  public get threadIds() {\n    return this._state.value.threadIds;\n  }\n\n  public get archivedThreadIds() {\n    return this._state.value.archivedThreadIds;\n  }\n\n  public get newThreadId() {\n    return this._state.value.newThreadId;\n  }\n\n  public get mainThreadId(): string {\n    return this._mainThreadId;\n  }\n\n  public getMainThreadRuntimeCore() {\n    const result = this._hookManager.getThreadRuntimeCore(this._mainThreadId);\n    if (!result) return EMPTY_THREAD_CORE;\n    return result;\n  }\n\n  public getItemById(threadIdOrRemoteId: string) {\n    return getThreadData(this._state.value, threadIdOrRemoteId);\n  }\n\n  public async switchToThread(threadIdOrRemoteId: string): Promise<void> {\n    const data = this.getItemById(threadIdOrRemoteId);\n    if (!data) throw new Error(\"Thread not found\");\n\n    if (this._mainThreadId === data.threadId) return;\n\n    const task = this._hookManager.startThreadRuntime(data.threadId);\n    if (this.mainThreadId !== undefined) {\n      await task;\n    } else {\n      task.then(() => this._notifySubscribers());\n    }\n\n    if (data.status === \"archived\") await this.unarchive(data.threadId);\n    this._mainThreadId = data.threadId;\n\n    this._notifySubscribers();\n  }\n\n  public async switchToNewThread(): Promise<void> {\n    // an initialization transaction is in progress, wait for it to settle\n    while (\n      this._state.baseValue.newThreadId !== undefined &&\n      this._state.value.newThreadId === undefined\n    ) {\n      await this._state.waitForUpdate();\n    }\n\n    const state = this._state.value;\n    let threadId: string | undefined = this._state.value.newThreadId;\n    if (threadId === undefined) {\n      do {\n        threadId = `__LOCALID_${generateId()}`;\n      } while (state.threadIdMap[threadId]);\n\n      const mappingId = createThreadMappingId(threadId);\n      this._state.update({\n        ...state,\n        newThreadId: threadId,\n        threadIdMap: {\n          ...state.threadIdMap,\n          [threadId]: mappingId,\n        },\n        threadData: {\n          ...state.threadData,\n          [threadId]: {\n            status: \"new\",\n            threadId,\n          },\n        },\n      });\n    }\n\n    return this.switchToThread(threadId);\n  }\n\n  private _onInitialize = async (task: Promise<CloudInitializeResponse>) => {\n    const threadId = this._state.value.newThreadId;\n    if (!threadId)\n      throw new Error(\n        \"ThreadListAdapter called onInitialize before switching to new thread\",\n      );\n\n    await this._state.optimisticUpdate({\n      execute: () => {\n        return task;\n      },\n      optimistic: (state) => {\n        return updateStatusReducer(state, threadId, \"regular\");\n      },\n      then: (state, { remoteId, externalId }) => {\n        const data = getThreadData(state, threadId);\n        if (!data) return state;\n\n        const mappingId = createThreadMappingId(remoteId);\n        return {\n          ...state,\n          threadIdMap: {\n            ...state.threadIdMap,\n            [remoteId]: mappingId,\n          },\n          threadData: {\n            ...state.threadData,\n            [threadId]: {\n              ...data,\n              remoteId,\n              externalId,\n            },\n          },\n        };\n      },\n    });\n  };\n\n  public rename(threadIdOrRemoteId: string, newTitle: string): Promise<void> {\n    const data = this.getItemById(threadIdOrRemoteId);\n    if (!data) throw new Error(\"Thread not found\");\n    if (data.status === \"new\") throw new Error(\"Thread is not yet initialized\");\n\n    return this._state.optimisticUpdate({\n      execute: () => {\n        return this._adapter.rename(data.remoteId, newTitle);\n      },\n      optimistic: (state) => {\n        const data = getThreadData(state, threadIdOrRemoteId);\n        if (!data) return state;\n\n        return {\n          ...state,\n          threadData: {\n            ...state.threadData,\n            [data.threadId]: {\n              ...data,\n              title: newTitle,\n            },\n          },\n        };\n      },\n    });\n  }\n\n  private async _ensureThreadIsNotMain(threadId: string) {\n    // if thread is main thread, switch to another thread\n    if (threadId === this._mainThreadId) {\n      const lastThreadId = this._state.value.threadIds[0];\n      if (lastThreadId) {\n        await this.switchToThread(lastThreadId);\n      } else {\n        await this.switchToNewThread();\n      }\n    }\n  }\n\n  public async archive(threadIdOrRemoteId: string) {\n    const data = this.getItemById(threadIdOrRemoteId);\n    if (!data) throw new Error(\"Thread not found\");\n    if (data.status !== \"regular\")\n      throw new Error(\"Thread is not yet initialized or already archived\");\n\n    return this._state.optimisticUpdate({\n      execute: async () => {\n        await this._ensureThreadIsNotMain(data.threadId);\n        return this._adapter.archive(data.remoteId);\n      },\n      optimistic: (state) => {\n        return updateStatusReducer(state, data.threadId, \"archived\");\n      },\n    });\n  }\n\n  public unarchive(threadIdOrRemoteId: string): Promise<void> {\n    const data = this.getItemById(threadIdOrRemoteId);\n    if (!data) throw new Error(\"Thread not found\");\n    if (data.status !== \"archived\") throw new Error(\"Thread is not archived\");\n\n    return this._state.optimisticUpdate({\n      execute: async () => {\n        try {\n          return await this._adapter.unarchive(data.remoteId);\n        } catch (error) {\n          await this._ensureThreadIsNotMain(data.threadId);\n          throw error;\n        }\n      },\n      optimistic: (state) => {\n        return updateStatusReducer(state, data.threadId, \"regular\");\n      },\n    });\n  }\n\n  public async delete(threadIdOrRemoteId: string) {\n    const data = this.getItemById(threadIdOrRemoteId);\n    if (!data) throw new Error(\"Thread not found\");\n    if (data.status !== \"regular\" && data.status !== \"archived\")\n      throw new Error(\"Thread is not yet initialized\");\n\n    return this._state.optimisticUpdate({\n      execute: async () => {\n        await this._ensureThreadIsNotMain(data.threadId);\n        return await this._adapter.delete(data.remoteId);\n      },\n      optimistic: (state) => {\n        return updateStatusReducer(state, data.threadId, \"deleted\");\n      },\n    });\n  }\n\n  private useBoundIds = create<string[]>(() => []);\n\n  public __internal_RenderComponent: FC = () => {\n    const id = useId();\n    useEffect(() => {\n      this.useBoundIds.setState((s) => [...s, id], true);\n      return () => {\n        this.useBoundIds.setState((s) => s.filter((i) => i !== id), true);\n      };\n    }, []);\n\n    const boundIds = this.useBoundIds();\n    const { Provider } = this.useProvider();\n\n    return (\n      <Provider>\n        {(boundIds.length === 0 || boundIds[0] === id) && (\n          // only render if the component is the first one mounted\n          <this._hookManager.__internal_RenderThreadRuntimes />\n        )}\n      </Provider>\n    );\n  };\n}\n"],"mappings":"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","names":["data"]}