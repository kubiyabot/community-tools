{"version":3,"sources":["../../../src/runtimes/local/LocalThreadListRuntimeCore.tsx"],"sourcesContent":["import type { Unsubscribe } from \"../../types\";\nimport { ThreadListRuntimeCore } from \"../core/ThreadListRuntimeCore\";\nimport { generateId } from \"../../utils/idUtils\";\nimport { LocalThreadRuntimeCore } from \"./LocalThreadRuntimeCore\";\n\nexport type ThreadListAdapter = {\n  subscribe(callback: () => void): Unsubscribe;\n};\n\nexport type LocalThreadData = {\n  readonly runtime: LocalThreadRuntimeCore;\n  readonly status: \"new\" | \"regular\" | \"archived\";\n  readonly threadId: string;\n  readonly title?: string | undefined;\n};\n\nexport type LocalThreadFactory = () => LocalThreadRuntimeCore;\n\nconst RESOLVED_PROMISE = Promise.resolve();\nexport class LocalThreadListRuntimeCore implements ThreadListRuntimeCore {\n  private _threadData = new Map<string, LocalThreadData>();\n  private _threadIds: readonly string[] = [];\n  private _archivedThreadIds: readonly string[] = [];\n  private _newThreadId: string | undefined;\n\n  public get newThreadId() {\n    return this._newThreadId;\n  }\n\n  public get threadIds() {\n    return this._threadIds;\n  }\n\n  public get archivedThreadIds() {\n    return this._archivedThreadIds;\n  }\n\n  private _mainThreadId!: string;\n\n  public get mainThreadId(): string {\n    return this._mainThreadId;\n  }\n\n  constructor(private _threadFactory: LocalThreadFactory) {\n    this.switchToNewThread();\n  }\n\n  public getMainThreadRuntimeCore() {\n    const result = this._threadData.get(this._mainThreadId)?.runtime;\n    if (!result)\n      throw new Error(\"Main thread not found. This is a bug in assistant-ui.\");\n    return result;\n  }\n\n  public getLoadThreadsPromise(): Promise<void> {\n    return RESOLVED_PROMISE;\n  }\n\n  public getItemById(threadId: string) {\n    return this._threadData.get(threadId);\n  }\n\n  public async switchToThread(threadId: string): Promise<void> {\n    if (this._mainThreadId === threadId) return;\n\n    const data = this._threadData.get(threadId);\n    if (!data) throw new Error(\"Thread not found\");\n\n    if (data.status === \"archived\") await this.unarchive(threadId);\n\n    this._mainThreadId = data.threadId;\n    this._notifySubscribers();\n  }\n\n  public switchToNewThread(): Promise<void> {\n    if (this._newThreadId === undefined) {\n      let threadId: string;\n      do {\n        threadId = generateId();\n      } while (this._threadData.has(threadId));\n\n      const runtime = this._threadFactory();\n      const dispose = runtime.unstable_on(\"initialize\", () => {\n        dispose();\n        const data = this._threadData.get(threadId);\n        if (!data) throw new Error(\"Thread not found\");\n\n        this._stateOp(threadId, \"regular\");\n      });\n      this._threadData.set(threadId, {\n        runtime,\n        status: \"new\",\n        threadId,\n      });\n      this._newThreadId = threadId;\n    }\n\n    this.switchToThread(this._newThreadId);\n    return Promise.resolve();\n  }\n\n  private async _stateOp(\n    threadId: string,\n    newState: \"regular\" | \"archived\" | \"deleted\",\n  ) {\n    const data = this._threadData.get(threadId);\n    if (!data) throw new Error(\"Thread not found\");\n\n    const { status: lastState } = data;\n    if (lastState === newState) return;\n\n    // lastState\n    switch (lastState) {\n      case \"new\":\n        this._newThreadId = undefined;\n        break;\n      case \"regular\":\n        this._threadIds = this._threadIds.filter((t) => t !== threadId);\n        break;\n      case \"archived\":\n        this._archivedThreadIds = this._archivedThreadIds.filter(\n          (t) => t !== threadId,\n        );\n        break;\n\n      default: {\n        const _exhaustiveCheck: never = lastState;\n        throw new Error(`Unsupported state: ${_exhaustiveCheck}`);\n      }\n    }\n\n    // newState\n    switch (newState) {\n      case \"regular\":\n        this._threadIds = [...this._threadIds, data.threadId];\n        break;\n\n      case \"archived\":\n        this._archivedThreadIds = [...this._archivedThreadIds, data.threadId];\n        break;\n\n      case \"deleted\":\n        this._threadData.delete(threadId);\n        break;\n\n      default: {\n        const _exhaustiveCheck: never = newState;\n        throw new Error(`Unsupported state: ${_exhaustiveCheck}`);\n      }\n    }\n\n    if (newState !== \"deleted\") {\n      this._threadData.set(threadId, {\n        ...data,\n        status: newState,\n      });\n    }\n\n    if (\n      threadId === this._mainThreadId &&\n      (newState === \"archived\" || newState === \"deleted\")\n    ) {\n      const lastThreadId = this._threadIds[0];\n      if (lastThreadId) {\n        await this.switchToThread(lastThreadId);\n      } else {\n        await this.switchToNewThread();\n      }\n    } else {\n      this._notifySubscribers();\n    }\n  }\n\n  public rename(threadId: string, newTitle: string): Promise<void> {\n    const data = this._threadData.get(threadId);\n    if (!data) throw new Error(\"Thread not found\");\n\n    this._threadData.set(threadId, {\n      ...data,\n      title: newTitle,\n    });\n    this._notifySubscribers();\n    return Promise.resolve();\n  }\n\n  public archive(threadId: string): Promise<void> {\n    const data = this._threadData.get(threadId);\n    if (!data) throw new Error(\"Thread not found\");\n    if (data.status !== \"regular\")\n      throw new Error(\"Thread is not yet initialized or already archived\");\n\n    this._stateOp(threadId, \"archived\");\n    return Promise.resolve();\n  }\n\n  public unarchive(threadId: string): Promise<void> {\n    const data = this._threadData.get(threadId);\n    if (!data) throw new Error(\"Thread not found\");\n    if (data.status !== \"archived\") throw new Error(\"Thread is not archived\");\n\n    this._stateOp(threadId, \"regular\");\n    return Promise.resolve();\n  }\n\n  public delete(threadId: string): Promise<void> {\n    const data = this._threadData.get(threadId);\n    if (!data) throw new Error(\"Thread not found\");\n    if (data.status !== \"regular\" && data.status !== \"archived\")\n      throw new Error(\"Thread is not yet initialized\");\n\n    this._stateOp(threadId, \"deleted\");\n    return Promise.resolve();\n  }\n\n  private _subscriptions = new Set<() => void>();\n\n  public subscribe(callback: () => void): Unsubscribe {\n    this._subscriptions.add(callback);\n    return () => this._subscriptions.delete(callback);\n  }\n\n  private _notifySubscribers() {\n    for (const callback of this._subscriptions) callback();\n  }\n}\n"],"mappings":"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","names":[]}