// src/runtimes/local/LocalRuntimeCore.tsx
import { BaseAssistantRuntimeCore } from "../core/BaseAssistantRuntimeCore.mjs";
import { LocalThreadRuntimeCore } from "./LocalThreadRuntimeCore.mjs";
import { LocalThreadListRuntimeCore } from "./LocalThreadListRuntimeCore.mjs";
import { fromThreadMessageLike } from "../external-store/ThreadMessageLike.mjs";
import { generateId } from "../../internal.mjs";
import { getAutoStatus } from "../external-store/auto-status.mjs";
var getExportFromInitialMessages = (initialMessages) => {
  const messages = initialMessages.map((i, idx) => {
    const isLast = idx === initialMessages.length - 1;
    return fromThreadMessageLike(i, generateId(), getAutoStatus(isLast, false));
  });
  return {
    messages: messages.map((m, idx) => ({
      parentId: messages[idx - 1]?.id ?? null,
      message: m
    }))
  };
};
var LocalRuntimeCore = class extends BaseAssistantRuntimeCore {
  threadList;
  Provider = void 0;
  _options;
  constructor(options, initialMessages) {
    super();
    this._options = options;
    this.threadList = new LocalThreadListRuntimeCore(() => {
      return new LocalThreadRuntimeCore(
        this._proxyConfigProvider,
        this._options
      );
    });
    if (initialMessages) {
      this.threadList.getMainThreadRuntimeCore().import(getExportFromInitialMessages(initialMessages));
    }
  }
  reset({
    initialMessages
  } = {}) {
    this.threadList.switchToNewThread();
    if (!initialMessages) return;
    this.threadList.getMainThreadRuntimeCore().import(getExportFromInitialMessages(initialMessages));
  }
};
export {
  LocalRuntimeCore
};
//# sourceMappingURL=LocalRuntimeCore.mjs.map