tools:
  - name: request_access
    alias: request_access
    description: A tool to request access, generating an IAM policy based on a description and creating an approval request in SQLite and sending a webhook notification.
    type: python
    content: |
      import os
      import sqlite3
      import sys
      from datetime import datetime, timedelta
      import requests
      from litellm import completion
      import uuid

      USER_EMAIL = os.getenv('KUBIYA_USER_EMAIL')
      SLACK_CHANNEL_ID = os.getenv('SLACK_CHANNEL_ID')
      SLACK_THREAD_TS = os.getenv('SLACK_THREAD_TS')
      KUBIYA_USER_ORG = os.getenv('KUBIYA_USER_ORG')
      KUBIYA_API_KEY = os.getenv('KUBIYA_API_KEY')
      APPROVAL_SLACK_CHANNEL = os.getenv('APPROVAL_SLACK_CHANNEL')
      OPENAI_API_KEY = os.getenv('OPENAI_API_KEY')
      OPENAI_API_BASE = os.getenv('OPENAI_API_BASE')

      purpose = "{{.purpose}}"
      ttl = "{{.ttl}}"
      policy_name = "{{.policy_name}}"
      permission_set_name = "{{.permission_set_name}}"
      policy_description = "{{.policy_description}}"

      def generate_policy(policy_description: str) -> str:
          print("‚ú® Generating least privileged policy JSON...")
          messages = [{"content": f"Generate a least privileged policy JSON for the following description: {policy_description} - return the JSON object.",
           "role": "user"}]
          try:
              response = completion(model="gpt-4o", messages=messages)
              if not response['choices']:
                  print("‚ùå Error: No response from OpenAI API. Could not generate policy.")
                  sys.exit(1)
              content = response['choices'][0]['message']['content']
              start = content.find('{')
              end = content.rfind('}')
              return content[start:end+1]
          except Exception as e:
              print(f"‚ùå Policy generation failed: {e}")
              sys.exit(1)

      policy_json = generate_policy(policy_description)
      print(f"‚úÖ Generated least privileged policy JSON:\n\n{policy_json}")

      try:
          if ttl[-1] == 'm':
              ttl_minutes = int(ttl[:-1])
          elif ttl[-1] == 'h':
              ttl_minutes = int(ttl[:-1]) * 60
          elif ttl[-1] == 'd':
              ttl_minutes = int(ttl[:-1]) * 60 * 24
          else:
              print("‚ùå Error: Unsupported TTL format. Use 'm', 'h', or 'd'. Defaulting to 30 days.")
              ttl_minutes = 30 * 24 * 60
      except ValueError:
          print("‚ùå Error: Invalid TTL format. Defaulting to 30 days.")
          ttl_minutes = 30 * 24 * 60

      request_id = str(uuid.uuid4())

      print("üìù Creating approval request...")

      approval_request = {
          'user_email': USER_EMAIL,
          'purpose': purpose,
          'ttl_minutes': ttl_minutes,
          'policy_name': policy_name,
          'permission_set_name': permission_set_name,
          'policy_json': policy_json,
          'requested_at': datetime.utcnow().isoformat(),
          'expires_at': (datetime.utcnow() + timedelta(minutes=ttl_minutes)).isoformat(),
          'slack_channel_id': SLACK_CHANNEL_ID,
          'slack_thread_ts': SLACK_THREAD_TS,
          'approved': 'pending',
          'request_id': request_id
      }

      conn = sqlite3.connect('/sqlite_data/approval_requests.db')
      c = conn.cursor()
      try:
          c.execute('''ALTER TABLE approvals ADD COLUMN request_id text''')
      except sqlite3.OperationalError:
          pass

      c.execute('''CREATE TABLE IF NOT EXISTS approvals
                   (user_email text, purpose text, ttl_minutes int, policy_name text, permission_set_name text, policy_json text, requested_at text, expires_at text, slack_channel_id text, slack_thread_ts text, approved text, request_id text)''')

      c.execute("INSERT INTO approvals (user_email, purpose, ttl_minutes, policy_name, permission_set_name, policy_json, requested_at, expires_at, slack_channel_id, slack_thread_ts, approved, request_id) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)",
                (approval_request['user_email'], approval_request['purpose'], 
                 approval_request['ttl_minutes'], approval_request['policy_name'], approval_request['permission_set_name'], 
                 approval_request['policy_json'], approval_request['requested_at'], approval_request['expires_at'], 
                 approval_request['slack_channel_id'], approval_request['slack_thread_ts'], 'pending', approval_request['request_id']))
      conn.commit()
      print("‚úÖ Approval request created successfully.")

      # Cleanup old requests
      expiry_threshold = datetime.utcnow() - timedelta(days=30)
      c.execute("DELETE FROM approvals WHERE expires_at < ?", (expiry_threshold.isoformat(),))
      conn.commit()
      print("üßπ Cleaned up old, expired approval requests.")

      conn.close()

      entry = {
          "user_email": USER_EMAIL,
          "purpose": purpose,
          "ttl_minutes": ttl,
          "policy_name": policy_name,
          "permission_set_name": permission_set_name,
          "policy_json": policy_json,
          "request_id": request_id
      }

      # Create and send webhook
      prompt = f"You are an access management assistant. You are currently conversing with an approving group. Your task is to help the approving group decide whether to approve the following access request. You have a new access request from {USER_EMAIL} for the following purpose: {purpose}. The request will expire in {ttl}. The ID of the request is {request_id}. The policy to be created is: ```{policy_json}```\n\nCAREFULLY ASK IF YOU CAN MOVE FORWARD WITH THIS REQUEST. DO NOT EXECUTE THE REQUEST UNTIL YOU HAVE RECEIVED APPROVAL FROM THE USER YOU ARE ASSISTING."
      
      payload = {
          "agent_id": os.getenv('KUBIYA_AGENT_UUID'),
          "communication": {
              "destination": APPROVAL_SLACK_CHANNEL,
              "method": "Slack"
          },
          "created_at": datetime.utcnow().isoformat() + "Z",
          "created_by": USER_EMAIL,
          "name": "Approval Request",
          "org": KUBIYA_USER_ORG,
          "prompt": prompt,
          "source": "Triggered by an access request (Agent)",
          "updated_at": datetime.utcnow().isoformat() + "Z"
      }

      response = requests.post(
          "https://api.kubiya.ai/api/v1/event",
          headers={
              'Content-Type': 'application/json',
              'Authorization': f'UserKey {KUBIYA_API_KEY}'
          },
          json=payload
      )

      if response.status_code < 300:
          print(f"‚úÖ WAITING: Request submitted successfully and has been sent to an approver. Waiting for approval.")
          event_response = response.json()
          webhook_url = event_response.get("webhook_url")
          if webhook_url:
              requests.post(
                  webhook_url,
                  headers={'Content-Type': 'application/json'},
                  json=payload
              )
          else:
              print("‚ùå Error: No webhook URL returned in the response. Could not send webhook to approving channel.")
      else:
          print(f"‚ùå Error: {response.status_code} - {response.text}")

    args:
      purpose:
        description: The purpose of the request
        required: true
      ttl:
        description: "Time to live for the request (format: 1m, 1h, 1d - only minutes (m), hours (h), and days (d) are supported)"
        required: true
      policy_name:
        description: The name of the customer managed policy to create
        required: true
      permission_set_name:
        description: The name of the permission set to update
        required: true
      policy_description:
        description: "A NATURAL LANGUAGE description of the policy to generate - this will be used to generate the policy JSON - should be a precise description of the permissions required, eg: 'Allow the user to read from the S3 bucket named 'my-bucket' and write to the DynamoDB table named 'my-table'.'"
        required: true
    dependencies: |
      litellm
      requests
    env:
      - KUBIYA_USER_EMAIL # The email of the user requesting access (injected automatically by Kubiya)
      - SLACK_CHANNEL_ID # The Slack channel ID for the approval request (injected automatically by Kubiya)
      - SLACK_THREAD_TS # The Slack thread timestamp for the approval request (injected automatically by Kubiya)
      - KUBIYA_AGENT_UUID # The agent UUID (injected automatically by Kubiya)
      - KUBIYA_USER_ORG # The organization name (injected automatically by Kubiya)
      - KUBIYA_API_KEY # The API key for the Kubiya API
      - APPROVAL_SLACK_CHANNEL # The Slack channel ID for approval notifications
      - AWS_PROFILE # The AWS profile to use for the policy generation (injected automatically by Kubiya)
      - OPENAI_API_KEY # The API key for the OpenAI API (injected automatically by Kubiya in agent context, requires api key to run locally)
      - OPENAI_API_BASE # The base URL for the OpenAI API (injected automatically by Kubiya in agent context, locally defaults to https://api.openai.com)
    with_volumes:
      - name: sqlite_data
        path: /sqlite_data

  - name: approve_request
    alias: approve_request
    description: Allows admins to approve or reject access requests - upon approval, a task is scheduled to delete the permission set after the TTL
    type: python
    content: |
      import os
      import sqlite3
      import sys
      from datetime import datetime, timedelta
      import requests
      from pytimeparse.timeparse import timeparse

      APPROVER_USER_EMAIL = os.getenv('KUBIYA_USER_EMAIL')
      APPROVAL_SLACK_CHANNEL = os.getenv('APPROVAL_SLACK_CHANNEL')
      APPROVING_USERS = os.getenv('APPROVING_USERS', '').split(',')
      SLACK_API_TOKEN = os.getenv('SLACK_API_TOKEN')
      KUBIYA_API_KEY = os.getenv('KUBIYA_API_KEY')

      if not APPROVER_USER_EMAIL:
          print("‚ùå Missing APPROVER_USER_EMAIL environment variable")
          sys.exit(1)

      if "{{.approval_action}}" not in ['approved', 'rejected']:
          print("‚ùå Error: Invalid approval action. Use 'approved' or 'rejected'.")
          sys.exit(1)

      if APPROVER_USER_EMAIL not in APPROVING_USERS:
          print(f"‚ùå User {APPROVER_USER_EMAIL} is not authorized to approve this request")
          sys.exit(1)

      request_id = "{{.request_id}}"
      approval_action = "{{.approval_action}}"

      conn = sqlite3.connect('/sqlite_data/approval_requests.db')
      c = conn.cursor()

      # Remove expired requests
      c.execute("DELETE FROM approvals WHERE expires_at < ?", (datetime.utcnow().isoformat(),))
      conn.commit()

      c.execute("SELECT * FROM approvals WHERE request_id=? AND approved='pending'", (request_id,))
      approval_request = c.fetchone()

      if not approval_request:
          print(f"‚ùå No pending approval request found for request ID {request_id}")
          sys.exit(1)

      c.execute("UPDATE approvals SET approved=? WHERE request_id=?", (approval_action, request_id))
      conn.commit()
      conn.close()

      print(f"‚úÖ Approval request with ID {request_id} has been {approval_action}")

      if approval_action == "approved":
          duration_minutes = approval_request[2]
          duration_seconds = duration_minutes * 60

          end_time = datetime.fromisoformat(approval_request[7])
          
          task_payload = {
              "execution_delay": duration_seconds,
              # TODO:: Notify both ends on Slack (easy to do with a dedicated Slack tool)
              "task_description": f"Immediately remove policy {approval_request[3]} from permission set {approval_request[4]} as the TTL has expired",
              "channel_id": APPROVAL_SLACK_CHANNEL,
              "user_email": approval_request[0],
              "organization_name": os.getenv("KUBIYA_USER_ORG"),
              "agent": os.getenv("KUBIYA_AGENT_PROFILE")
          }
          response = requests.post(
              'https://api.kubiya.ai/api/v1/scheduled_tasks',
              headers={
                  'Authorization': f'UserKey {KUBIYA_API_KEY}',
                  'Content-Type': 'application/json'
              },
              json=task_payload
          )

          if response.status_code < 300:
              print(f"‚úÖ Scheduled task to remove policy {approval_request[3]} from permission set {approval_request[4]} in {duration_minutes} minutes (expires at {end_time})")
          else:
              print(f"‚ùå Error: {response.status_code} - {response.text}")

      slack_channel_id = approval_request[8]
      slack_thread_ts = approval_request[9]

      # Get permalink
      permalink_response = requests.get(
          "https://slack.com/api/chat.getPermalink",
          params={
              'channel': slack_channel_id,
              'message_ts': slack_thread_ts
          },
          headers={
              'Authorization': f'Bearer {SLACK_API_TOKEN}'
          }
      )
      permalink = permalink_response.json().get("permalink")

      action_emoji = ":white_check_mark:" if approval_action == "approved" else ":x:"
      action_text = "approved" if approval_action == "approved" else "rejected"
      approver_text = f"<@{APPROVER_USER_EMAIL}> {action_text} this request {action_emoji}"

      slack_payload_main_thread = {
          "channel": slack_channel_id,
          "text": f"<@{approval_request[0]}>, your request has been {approval_action}.",
          "blocks": [
              {
                  "type": "section",
                  "text": {
                      "type": "mrkdwn",
                      "text": f"*Request {approval_action}* {action_emoji}\n*Reason:* {approval_request[1]}\n*Access:* {approval_request[3]} for {approval_request[2]}\n*Status:* {approver_text}\n<{permalink}|View original conversation>"
                  }
              },
              {
                  "type": "actions",
                  "elements": [
                      {
                          "type": "button",
                          "text": {
                              "type": "plain_text",
                              "text": "‚ÜóÔ∏èüí¨ View Thread"
                          },
                          "url": permalink
                      }
                  ]
              }
          ],
      }

      slack_payload_in_thread = {
          "channel": slack_channel_id,
          "text": f"<@{approval_request[0]}>, your request has been {approval_action}.",
          "thread_ts": slack_thread_ts,
          "blocks": [
              {
                  "type": "section",
                  "text": {
                      "type": "mrkdwn",
                      "text": f"Good news! {approver_text} :tada:\n\nYou can now proceed with your request. Go ahead and try your brand new permissions! :rocket:\n\nNote: This permission will be removed automatically after {approval_request[2]} by the system."
                  }
              }
          ]
      }

      for slack_payload in [slack_payload_main_thread, slack_payload_in_thread]:
        slack_response = requests.post(
            "https://slack.com/api/chat.postMessage",
            headers={
                'Content-Type': 'application/json',
                'Authorization': f'Bearer {SLACK_API_TOKEN}'
            },
            json=slack_payload
        )

        if slack_response.status_code < 300:
            print(f"‚úÖ All done! Slack notification sent successfully. Response: {slack_response.text}")
        else:
            print(f"‚ùå Error sending Slack notification: {slack_response.status_code} - {slack_response.text}")

    args:
      request_id:
        description: The unique identifier for the request being approved or rejected
        required: true
      approval_action:
        description: Approval action (approved or rejected)
        required: true
    env:
      - KUBIYA_USER_EMAIL # The email of the user approving the request
      - APPROVING_USERS # A comma-separated list of users who are authorized to approve requests
      - APPROVAL_SLACK_CHANNEL # The Slack channel ID for approval notifications
      - SLACK_API_TOKEN # The Slack API token for sending messages
      - KUBIYA_API_KEY # The API key for the Kubiya API
      - KUBIYA_USER_ORG # The organization name (injected automatically by Kubiya)
      - KUBIYA_AGENT_PROFILE # The agent profile to use for the scheduled task (injected automatically by Kubiya)
    dependencies: |
      requests
      pytimeparse==1.1.8
    with_volumes:
      - name: sqlite_data
        path: /sqlite_data
